# 1. SSRF(Server-side Request Forgery) 란?
기존의 웹 서비스는 단일 서비스로 구현할 수 있었지만 최근의 웹 서비스는 지원하는 기능이 증가함에 따라 구성요소가 증가했습니다. 이에 따라 관리 및 코드의 복잡도를 낮추기 위해 **마이크로서비스**들로 웹 서비스를 구현하는 추세입니다. 이때 각 마이크로서비스는 주로 HTTP, GRPC 등을 사용해 API 통신을 합니다.

![[ssrf-1.png]]


**Server-side Request Forgery(SSRF)** 는 웹 서비스의 요청을 변조하는 취약점으로, 브라우저가 변조된 요청을 보내는 CSRF와는 다르게 웹 서비스의 권한으로 변조된 요청을 보낼 수 있습니다.

**최근의 대다수 서비스들은 마이크로서비스로 구조를 많이 바꾸고, 새롭게 개발하는 추세이기 때문에 SSRF 취약점의 파급력이 더욱 높아지고 있습니다.**

|**마이크로서비스란?**|
|---|
|마이크로서비스는 소프트웨어가 잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식입니다. 이러한 서비스는 독립적인 소규모 팀에서 보유합니다.|


# 2. SSRF 예시 

웹 서비스는 외부에서 접근할 수 없는 내부망의 기능을 사용할 때가 있습니다. 내부망의 기능은 **백오피스 서비스**를 예로 들 수 있습니다. 백오피스 서비스는 관리자 페이지라고도 불리며, 이용자의 행위가 의심스러울 때 해당 계정을 정지시키거나 삭제하는 등 관리자만이 수행할 수 있는 모든 기능을 구현한 서비스입니다. 이러한 서비스는 관리자만 이용할 수 있어야 하기 때문에 외부에서 접근할 수 없는 내부망에 위치합니다.

웹 서비스는 의심스러운 행위를 탐지하고 실시간으로 대응하기 위해 백오피스의 기능을 실행할 수 있습니다. 다시 말해, 웹 서비스는 외부에서 직접 접근할 수 없는 내부망 서비스와 통신할 수 있습니다. 만약 공격자가 SSRF 취약점을 통해 웹 서비스의 권한으로 요청을 보낼 수 있다면 공격자는 외부에서 간접적으로 내부망 서비스를 이용할 수 있고, 이는 곧 기업에 막대한 피해를 입힐 수 있습니다.

웹 서비스가 보내는 요청을 변조하기 위해서는 요청 내에 이용자의 입력값이 포함돼야 합니다. 입력값이 포함되는 예시로는 웹 서비스가 이용자가 입력한 URL에 요청을 보내거나 요청을 보낼 URL에 이용자 번호와 같은 내용이 사용되는 경우, 그리고 이용자가 입력한 값이 HTTP Body에 포함되는 경우로 나눠볼 수 있습니다.

그렇다면, 다음 장에서 SSRF 취약점이 발생하는 예시 코드와 함께 자세히 알아보도록 하겠습니다.


# 3. 예시 1 (이용자가 입력한 URL에 요청을 보내는 경우)

**아래 코드**는 이용자가 전달한 URL에 요청을 보내는 예제 코드입니다. 코드를 살펴보면, 두 가지의 엔드포인트가 존재합니다. 다음은 각 엔드포인트에 대한 설명입니다.

```
# pip3 install flask requests # 파이썬 flask, requests 라이브러리를 설치하는 명령입니다.# python3 main.py # 파이썬 코드를 실행하는 명령입니다. 
from flask 
import Flask, request
import requests 

app = Flask(__name__) 
@app.route("/image_downloader")
def image_downloader(): 
	# 이용자가 입력한 URL에 HTTP 요청을 보내고 응답을 반환하는 페이지 입니다. 
	# URL 파라미터에서 image_url 값을 가져옵니다. 
	image_url = request.args.get("image_url", "") 
	# requests 라이브러리를 사용해서 image_url URL에 HTTP GET 메소드 요청을 보내고 결
		과를 response에 저장합니다. 
	response = requests.get(image_url)
	return ( # 아래의 3가지 정보를 반환합니다. 
		response.content, # HTTP 응답으로 온 데이터 
		200, # HTTP 응답 코드 
		# HTTP 응답으로 온 헤더 중 Content-Type(응답 내용의 타입) 
		{"Content-Type": response.headers.get("Content-Type", "")}, 
	) 

@app.route("/request_info")
def request_info(): 
	# 접속한 브라우저(User-Agent)의 정보를 출력하는 페이지 입니다. 
	return request.user_agent.string 
	
app.run(host="127.0.0.1", port=8000)

```

## 문제점 확인

다음과 같이 **image_downloader** 엔드포인트의 `image_url`에 **request_info** 엔드포인트 경로를 입력해봅니다.

> http://127.0.0.1:8000/image_downloader?image_url=http://127.0.0.1:8000/request_info

위 경로에 접속하면 **image_downloader**에서는 `http://127.0.0.1:8000/request_info` URL에 HTTP 요청을 보내고 응답을 반환합니다. 반환한 값을 확인해보면 브라우저로 **request_info** 엔드포인트에 접속했을 때와 다르게 브라우저 정보가 `python-requests/<LIBRARY_VERSION>`인 것을 확인할 수 있습니다.

접속한 브라우저 정보로 `python-requests`가 출력된 이유는 웹 서비스에서 HTTP 요청을 보냈기 때문입니다. 이처럼 이용자가 웹 서비스에서 사용하는 마이크로서비스의 API 주소를 알아내고, `image_url`에 주소를 전달하면 외부에서 직접 접근할 수 없는 마이크로서비스의 기능을 임의로 사용할 수 있습니다.



# 4. 예시 2(웹 서비스의 요청 URL에 이용자의 입력값이 포함되는 경우)

**아래 코드**는 이용자의 입력값이 포함된 URL에 요청을 보내는 예제 코드입니다. 코드를 살펴보면, 두 가지의 엔드포인트가 존재합니다. 다음은 각 엔드포인트에 대한 설명입니다.

```
INTERNAL_API = "http://api.internal/"
# INTERNAL_API = "http://172.17.0.3/" 

@app.route("/v1/api/user/information")
def user_info(): 
	user_idx = request.args.get("user_idx", "") 
	response = requests.get(f"{INTERNAL_API}/user/{user_idx}") 
	
@app.route("/v1/api/user/search")
def user_search(): 
	user_name = request.args.get("user_name", "") 
	user_type = "public" 
	response = requests.get(f"{INTERNAL_API}/user/search?user_name={user_name}&user_type={user_type}")
```


### user_info

이용자가 전달한 `user_idx` 값을 내부 API의 URL 경로로 사용합니다.

|   |   |
|---|---|
||http://x.x.x.x/v1/api/user/information?user_idx=1|

이용자가 위와 같이 `user_idx`를 1로 설정하고 요청을 보내면 웹 서비스는 다음과 같은 주소에 요청을 보냅니다.

|   |   |
|---|---|
||http://api.internal/user/1|

### user_search

이용자가 전달한 `user_name` 값을 내부 API의 쿼리로 사용합니다.

|   |   |
|---|---|
||http://x.x.x.x/v1/api/user/search?user_name=hello|

이용자가 위와 같이 `user_name`을 “hello”로 설정하고 요청을 보내면 웹 서비스는 다음과 같은 주소에 요청을 보냅니다.

|   |   |
|---|---|
||http://api.internal/user/search?user_name=hello&user_type=public|

## 문제점 확인

웹 서비스가 요청하는 URL에 이용자의 입력값이 포함되면 요청을 변조할 수 있습니다. 이용자의 입력값 중 URL의 구성 요소 문자를 삽입하면 API 경로를 조작할 수 있습니다. 예를 들어, 예시 코드의 `user_info` 함수에서 `user_idx`에 `../search`를 입력할 경우 웹 서비스는 다음과 같은 URL에 요청을 보냅니다.

|   |   |
|---|---|
||http://api.internal/search|

`..`는 상위 경로로 이동하기 위한 구분자로, 해당 문자로 요청을 보내는 경로를 조작할 수 있습니다. 해당 취약점은 경로를 변조한다는 의미에서 **Path Traversal**이라고 불립니다.

이 외에도, `#` 문자를 입력해 경로를 조작할 수 있습니다. 예를 들어, `user_search` 함수에서 `user_name`에 `secret&user_type=private#`를 입력할 경우 웹 서비스는 다음과 같은 URL에 요청을 보냅니다.

|   |   |
|---|---|
||http://api.internal/search?user_name=secret&user_type=private#&user_type=public|

`#` 문자는 Fragment Identifier 구분자로, 뒤에 붙는 문자열은 API 경로에서 생략됩니다. 따라서 해당 URL은 실제로 아래와 같은 URL을 나타냅니다.

|   |   |
|---|---|
||http://api.internal/search?user_name=secret&user_type=private|


# 5. 예시 3(웹 서비스의 요청 Body에 이용자의 입력값이 포함되는 경우)

**아래 코드**는 이용자의 입력값이 요청의 Body에 포함되는 예제 코드입니다. 코드를 살펴보면, 세 가지의 엔드포인트가 존재합니다. 다음은 각 엔드포인트에 대한 설명입니다.

```
# pip3 install flask
# python main.py 
from flask import Flask, request, session
import requests
from os import urandom 

app = Flask(__name__)
app.secret_key = urandom(32)
INTERNAL_API = "http://127.0.0.1:8000/"
header = {"Content-Type": "application/x-www-form-urlencoded"} 

@app.route("/v1/api/board/write", methods=["POST"])
def board_write(): 
	session**["idx"]** = "guest" # session idx를 guest로 설정합니다. 
	# title 값을 form 데이터에서 가져옵니다.
	title = request.form.get("title", "")  
	# body 값을 form 데이터에서 가져옵니다.
	body = request.form.get("body", "")  
	 # 전송할 데이터를 구성합니다.
	data = f"title={title}&body={body}&user={session['idx']}" 
	# INTERNAL API 에 이용자가 입력한 값을 HTTP BODY 데이터로 사용해서 요청합니다.
	response = requests.post(f"{INTERNAL_API}/board/write", 
		headers=header, data=data) 
	return response.content # INTERNAL API 의 응답 결과를 반환합니다. 
	
@app.route("/board/write", methods=["POST"])
def internal_board_write(): 
	# form 데이터로 입력받은 값을 JSON 형식으로 반환합니다. 
	title = request.form.get("title", "") 
	body = request.form.get("body", "") 
	user = request.form.get("user", "") 
	info = { 
		"title": title, 
		"body": body, 
		"user": user, 
	} 
	return info

@app.route("/")
def index():
	# board_write 기능을 호출하기 위한 페이지입니다. 
	return """ 
		<form action="/v1/api/board/write" method="POST"> 
			<input type="text" placeholder="title" name="title"/><br/> 
			<input type="text" placeholder="body" name="body"/><br/> 
			<input type="submit"/> 
		</form> 
	""" 
	
app.run(host="127.0.0.1", port=8000, debug=True)
```

### board_write

이용자의 입력값을 HTTP Body에 포함하고 내부 API로 요청을 보냅니다. 전송할 데이터를 구성할 때 세션 정보를 "guest" 계정으로 설정합니다.

### internal_board_write

`board_write` 함수에서 요청하는 내부 API를 구현한 기능입니다. 전달된 title, body 그리고 계정 이름을 JSON 형식으로 변환하고 반환합니다.

### index

board_write 기능을 호출하기 위한 인덱스 페이지 입니다.

## 문제점 확인

위 코드를 실행하고 다음 URL에 접속하면 `title`과 `body`를 입력하는 페이지가 표시됩니다.

|   |   |
|---|---|
||http://127.0.0.1:8000|

입력창에 값을 입력하고 제출 버튼을 누르면 다음과 같은 응답을 확인할 수 있습니다.

|   |   |
|---|---|
||{ "body": "body", "title": "title", "user": "guest" }|

요청을 전송할 때 세션 정보를 "guest"로 설정했기 때문에 `user`가 "guest"인 것을 확인할 수 있습니다. 예시 코드를 살펴보면, 내부 API로 요청을 보내기 전에 다음과 같이 데이터를 구성하는 것을 확인할 수 있습니다.

|   |   |
|---|---|
||data = f"title={title}&body={body}&user={session['idx']}|

데이터를 구성할 때 이용자의 입력값인 `title`, `body` 그리고 `user`의 값을 파라미터 형식으로 설정합니다. 이로 인해 이용자가 URL에서 파라미터를 구분하기 위해 사용하는 구분 문자인 `&`를 포함하면 설정되는 `data`의 값을 변조할 수 있습니다. `title`에서 `title&user=admin`를 삽입하면 다음과 같이 `data`가 구성됩니다.

|   |   |
|---|---|
||title=title&user=admin&body=body&user=guest|

이용자가 `&` 구분자를 포함해 user 파라미터를 추가했습니다. 내부 API에서는 전달받은 값을 파싱할 때 앞에 존재하는 파라미터의 값을 가져와 사용하기 때문에 `user`의 값을 변조할 수 있습니다. `title&user=admin`를 삽입했을 때의 실행 결과를 확인해보면 `user`가 "admin"으로 변조된 것을 확인할 수 있습니다.

|   |   |
|---|---|
||{ "body": "body", "title": "title", "user": "admin" }|



# 6.  간단하게 정리
url 에서  &를 사용하거나 ../  상위 경로 이동 등을 사용하거나 또는 url자체를 파라미터로 받는 경우 취약점 공격 가능 

api로 통신 


- **구분 문자(Delimiter)**: 일반 텍스트 또는 데이터 스트림에서 별도의 독립적 영역 사이의 경계를 지정하는 데 사용하는 하나의 문자 혹은 문자들의 배열. URL 에서 구분 문자는 "/"(Path identifier), "?" (Query identifier) 등 이 있으며 구분 문자에 따라 URL의 해석이 달라질 수 있음.