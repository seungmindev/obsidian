# 1. 포인터 

**포인터 선언**
```
int* itpr 
```

**포인터 사용**
```
prtVar = &var;  //ptrVar이 var을 가리키게함
*ptrVar = value; //ptrVar의 값을 변경 즉 var의 값이 변경 

int a;
int* iPtr = &a;
*iPtr = 10;  // a = 10 
iptr= 10 ; // 에러 남 , 그리고 주소를 입력해야됨 
```

**포인터 사용예**
```
int main()
{
	int a= 10, b =100;
	int* ptr = &a;

	cout << "ptr이 가리키는 곳의 값" << *ptr << endl;
	*ptr = 20; // ptr이 가리키는 곳에 20 저장 
	cout << "변수 a의 값 : " << a << endl;
	ptr = &b; // ptr이 b를 가리키게함 
	cout << "변수 b의 값" << *ptr << endl;
	return 0;
}
```

# 2. 동적메모리할당

* 프로그램 동작중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당 
* 기억공간의 생성시점 : new 연산자의 실행시점
* 기억공간의 종료시점 : delete 연산자의 실행시점

**메모리할당연산자**
```
ptrVar = new TypeName;
ptrVar = new TypeName[n];
```

**메모리반납연산자**
```
delete ptrVar;
delete [] ptrVar; // 괄호안에 개수 입력 필요 x 
```

**단일데이터공간의 할당 및 반납**
```
int* intPtr;
intPtr = new int;
*intPtr = 10;
...
delete intPtr;
intPtr = nullptr; // nullptr=0 값 , 이문장은 안써도 되지만 권장 

// 그외 
if(intPtr) 
if(!intPtr) 
```

**배열 데이터 공간의 할당 및 반납**
```
int* intPtr;
intPtr = new int[4];

*intPtr = 10; // 0번째 배열에 10 
*(intPtr + 1) = 20; // 1번째 배열에 20, * 우선순위 높기에 괄호필수 
intPtr[2] = 30; // 위와 동일한 방식 
...
delete []intPtr;
intPtr = nullptr;
```

배열도 사실 거의 포인터.. 

**배열 예시**
```
char* sPtr;
int maxSLen;
cout << "단어의 최대길이 : " ;
cin >> maxSLen;
sPtr = new char[maxSLen+1]; // 마지막 null문자 라서 +1 
cout << "단어를 입력하시오" ;
cin >> sPtr;
int len{0}; // 단어의 문자수 
for(char* p = sPtr; *p ; p++){ //*p 는 p의 값 이 \0이 아닐때 까지 
	++len;
} 
cout << sPtr << "의 문자수 " << len << endl;
delete[] sPtr;

```
# 3. 참조

**참조란?**
* 포인터와 비슷
* l-value 참조와 , R-value 참조 가 있음 

**l-value**
```
int a= 10, b=20;
int& aRef = a;
cout << aRef = << endl;
aRef = 100;
aRef = b; 
```

**const참조**
* 참조하는 대상의 값을 바꿀 수 없음
```
int x{10};
const int& xRef = x;
cout << xRef << endl; 
xRef += 10; // 오류 : const 참조로 값 수정 불가 
```

**포인터와 다른점**
* 참조변수 값 사용시 포인터처럼 * x 
* 참조변수는 초기화를 통해 반드시 어떤 대상을 참좀해야함 
* 참조변수는 하나의 대상만 참조 할 수 있다. 


과제

cout << "학번: 2023 , 이름 : 이승민" << endl

