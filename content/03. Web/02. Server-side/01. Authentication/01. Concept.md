
# 1. 인증(Authentication)이란 ?

> 사용자의 신원을 확인하는 프로세스 

- 지식기반 요소(knowledge factors) : 비밀번호 
- 소유기반 요소(possession factors) : 핸드폰
- 고유기반 요소(inherence factors) : 생체인식
 
# 2. 인가(Authorization)란? 

> 인증 된 사용자에게 주어지는 권한 

**인증, 인가의 차이점 예시**

- 해당 아이디로 로그인 하려는 사용자가 실제로 계정을 만든 본인인지 확인                       -> 인증
- 로그인한 사용자의 권한에 따라 수행가능한 작업이 결정됨 다른 사용자의 계정삭제 등     -> 인가 

# 3. 인증 취약점이 발생하는 방식 

- brute-force attacks(무차별 대입 공격)
- Logic flaws(논리결함) or poor coding(코딩불량)으로 인한 인증 우회
  -> broken authentication(깨진 인증)이라고 부름

# 4. Vulnerabilities in password-based login (비밀번호 기반 취약점)
## 4.1 Brute-force attacks(무차별 대입 공격)

**사용자 이름**
- 비즈니스 메일은 추측 가능 ex) firstname.lastname@somecompany.com 
- 관리자 아이디 추측 ex) admin, administrator
- 웹사이트 내에서 로그인 하지 않고도 사용자의 이름을 노출 시킬 수 도 있음
- HTTP응답 에서 관리자나 IT 지원과 같은 높은 권한 가진 사용자 이메일 주소 포함 될 수 도 있음

**사용자 암호**
- 사용자는 임의의 문자 조합으로 강력한 비밀번호를 만드는 대신 기억할 수 있는 비밀번호를 선택하여 비밀번호 정책에 맞추려고 시도하는 경우가 많다. ex) 'mypassword' 대신     'Mypassword1!' 또는 'Myp4\$\$w0rd'
- 정책에 따라 정기적으로 비밀번호를 변경하도록 요구할 때에도 사용자가 기본 비밀번호를 사소하고 예측 가능하게 변경하는 것도 일반적이다. ex) 'Mypassword1!' 에서 'Mypassword1?' 또는 'Mypassword2!'

**사용자 이름 열거**
- 유효한 사용자 이름을 찾는 것을 의미 
- **상태코드의 차이** 다른 상태 코드가 반환되는 경우 이는 사용자 이름이 정확하다는 강력한 표시
- **오류메시지의 차이** 사용자 이름과 비밀번호가 모두 틀린지, 아니면 비밀번호만 틀린지에 따라 반환되는 오류 메시지가 다를 수 있다.
- **응답시간의 차이**  대부분의 요청이 비슷한 응답 시간으로 처리된 경우, 이 시간에서 벗어나는 것은 뒤에서 뭔가 다른 일이 일어나고 있음을 나타낸다. 이는 추측한 사용자 이름이 정확할 수도 있다는 또 다른 표시. 예를 들어 웹사이트에서는 사용자 이름이 유효한 경우에만 비밀번호가 올바른지 확인할 수 있다. 이 추가 단계로 인해 응답 시간이 약간 증가할 수 있다. 이는 미묘할 수 있지만 공격자는 웹 사이트에서 처리하는 데 눈에 띄게 오래 걸리는 지나치게 긴 비밀번호를 입력하여 이러한 지연을 더욱 분명하게 만들 수 있다.

**무차별 대입 보호의 결함**
- 다량의 로그인 실패 시 IP주소차단 
   일부 구현에서는 IP 소유자가 성공적으로 로그인하면 실패한 시도 횟수에 대한 카운터가 재설정됩니다. 이는 공격자가 이 제한에 도달하는 것을 방지하기 위해 몇 번의 시도마다 자신의 계정에 로그인하면 된다는 것을 의미합니다. 이 경우 단어 목록 전체에 정기적으로 **자신의 로그인 자격 증명을 포함**시키는 것만으로도 이러한 방어 기능을 사실상 쓸모 없게 만들 수 있습니다.
- 다량의 로그인 실패 시 계정 잠금 
   - 계정이 잠겨있음을 나타내는 서버의 응답도 공격자가 사용자의 이름을 열거하는데 도움됨
   - 임의의 계정 액세스에 대한 완벽한 대처라 보기는 어렵다. 최소한 한 사람의 사용자가 가질 가능성이 있는 매우 작은 비밀번호 목록을 구한 후 (5회이상 잠김의 경우 4개만)    모든 계정에 4번씩만 대입하여 무차별 공격 가능하다.
   - credential stuffing attacks 는 가능하다.   크리덴셜 스터핑이란 해커가 다크 웹에서 구매한 인증정보로, 봇을 사용해 웹사이트에 지속적으로 접속하려 시도하는 자동화된 사이버 공격
- 다량의 로그인 요청 시 IP주소 차단
   짧은 시간 내에 너무 많은 로그인 요청을 하면 IP 주소를 차단하는 것, 이 경우 다음 방법중 하나로만 차단 해제 가능 
   - 일정시간 지나면 자동
   - 관리자가 수동
   - CAPTCHA 통과 
   이 또한 우회 가능 IP를 조작하거나,  단일 요청으로 여러 비밀번호를 추측할 수 있다면 


## 4.2 Exploiting HTTP basic authentication(HTTP 기본인증 악용)

> HTTP 기본인증은 클라이언트가 서버로부터 수신하는 토큰이다. 
> 해당 토큰은 사용자 이름과 비밀번호로 구성되어 있고 base64로 인코딩 된다. 

- 이 토큰은 브라우저가 저장 관리하고, 
- 이후 모든 요청의 Authorization헤더에 아래와 같이 자동으로 추가된다. 
```
Authorization: Basic base64(username:password)
```

**취약점**(일반토큰이랑 차이가있나? )
1. 요청마다 로그인 자격증명을 주고받음으로 중간자공격 으로 캡처 가능 (HSTS있으면 방어 가능) 아이디 비밀번호 자체를 주고받음으로 요청을 가로채면 아이디와 비밀번호를 쉽게 볼 수 있다. 
2. HTTP 기본인증은 무차별 대입보호를 지원하지 않는 경우가 많음, 토큰은 정적 값으로 만 되어 있으므로 무차별 대입 공격에 더 취약할 수 있다.
3. CSRF에 취약 하다. 


# 5. Vulnerabilites in multi-factor authentication (다중요소 인증 취약점 )

- knowledge factors & possession factors 을 기반으로 2단계 인증을 보는 것이 일반화 되고 있다. 
- 이메일 기반 2FA는 진정한 이중 인증 기반이 아니다. 지식 기반 인증을 두 번 보는 것 뿐이다.
## 5.1 Two-factor authentication tokens(이중 인증 토큰)

- RSA Token or RSA SecurID Token - 옛날 방식이라서 요즘에는 안하는 추세
- Duo MFA(Multi-Factor Authentication) - cisco사 제품
   - 개인키는 모바일 장치에 공개키는 서버에 따라서 서버가 침해되더라도 모든 사용자의 정보에 접근 할 수 있지 않음
   - 15000명의 사용자를 둔 대규모 기술회사 단 이틀만에 전체 직원에 배포된 RSA를 Duo의 솔루션으로 교체 및 12개의 애플리케이션을 통합 

> reference
> https://www.cisco.com/c/m/ko_kr/duo/product/multi-factor-authentication-mfa.html

**문자메시지 인증**

- 기본적으로 possession factors이지만 남용될 우려가있다. 
- SMS를 통해 전송 되기 때문에 가로채질 가능성이 있다. 공격자가 피해자의 전화번호로 SIM 카드를 부정하게 획득하는 SIM 스와핑의 위험도 있다. (이거는 OTP나 다른 인증도 동일하지 않을까?)

## 5.2 Bypassing two-factor authentication

- 로그인 후 이중인증 전에 '로그인전용' 페이지로 건너뛰어 본다. 
## 5.3 Bypassing two-factor authentication with flawed verification(결함이 있는 검증으로 이중 인증 우회)

> 초기 로그인 단계를 완료한 후 동일한 사용자가 두 번째 단계를 완료하고 있는지 적절한 검사를 하지 않을 때 발생

- 첫 번째 로그인 프로세스에서 인증 후 두 번째 단계로 이동하기 전에 자신의 계정과 관련된 쿠키가 할당된다 .
```
HTTP/1.1 200 OK 
Set-Cookie: account=carlos
```

- 두 번째 로그인 프로세스 확인 코드를 제출할 때 다른 사용자의 이름으로 쿠키 값을 변경하여 제출한다 
```
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456
```

## 5.4 Brute-forcing 2FA verification codes(무차별 대입 2FA 인증 코드)

- 2차 인증코드에 대한 적절할 무차별 대입 공격의 보호기능이 필요하다 
- 일부 웹사이트는 잘못된 인증코드를 일정 개수 이상 입력하면 사용자를 자동으로 로그아웃 시켜 방지하려고 한다. 하지만 이 다단계 프로세스를 자동화 할 수 도 있기 때문에 실제로는 효과적이지 않다. (Turbo Intruder 확장프로그램 )


# 6. Vulnerabilites in other authentication mechanisms (기타 인증 메커니즘 취약점)
## 6.1 Keeping users logged in (사용자 로그인 유지)

- 일종의 "기억하기" 토큰을 생성해서 구현되는 경우가 많으며, 영구 쿠키에 저장된다. 
- 이 쿠키는 추측하는 것이 불가능 하도록 하는 것 이 가장 좋으나 , 일부 웹사이트에서는 사용자의 이름 및 타임스탬프와 같은 정적 값의 예측 가능한 연결 기반으로 만든다. 
   이러한 공식이 완성되면 무차별 대입 공격으로 타 사용자의 계정에 액세스 할 수 있다. 
- Base64로 암호화  되어있다 하더라도 간단한 양방향 인코딩이면 쉽게 복호화 가능하며, 
- 단방향 해시함수와 함께 적절한 암호화를 사용하더라도 완전히 안전하지는 않음 
   해싱알고리즘을 쉽게 식별 할 수 있고 솔트를 사용하지 않는 경우, 단순히 단어 목록을 해싱하여 잠재적으로 쿠키 무차별 공격 가능하다. 

- XSS 와 같은 일반적인 기술로 다른사용자의 기억하기 쿠키를 훔치고 쿠키가 어떻게 구성되는지 추론할 수 있다. 
- 웹사이트가 오픈소스 기반이면, 쿠키 구성의 주요 세부정보가 공개적으로 문서화 될 수 도 있다.
- 드문 경우지만, 쿠키가 해시된 경우에도 쿠키에서 일반 텍스트로 사용자의 실제 비밀번호를 얻을 수 있다. 잘 알려진 비밀번호 목록의 해시 버전은 온라인에서 쉽게 얻을 수 있다. 
  따라서 솔트가 중요하다. 

## 6.2 Resetting user passwords (사용자 비밀번호 재설정)

**이메일로 비밀번호 보내기**
- 생성된 비밀번호가 매우 짧은 기간 후에 만료되거나, 즉시 변경하도록 한다. 
- 사용자는 안전하지 않은 채널을 통해 여러 장치 간에 받은 편지함을 자동으로 동기화 하기도한다. 

**URL을 사용하여 비밀번호 재설정**

- 비밀번호 재설정 보다 강력한 방법은 사용자에게 비밀번호 재설정 페이지로 연결 되는 고유 URL을 보내는 것이다. 
```
// 안전하지 않은 예
http://vulnerable-website.com/reset-password?user=victim-user
```

- 엔트로피가 높고 추측하기 어려운 토큰 생성, 이 토큰은 짧은 시간 후에 만료되어야 하며 비밀번호가 재설정 된 후 즉시 폐기 되어야 한다.
```
http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8
```

- 일부 웹사이트에서는 재설정 양식을 제출할때 토큰을 제대로 검증하지 않는다. 이경우 공격자는 자신의 계정에서 재설정 양식을 방문하여 토큰을 삭제하고 이 페이지를 활용해 임의의 사용자의 비밀번호를 재설정 할 수 있다. 

## 6.3 Changing user passwords (사용자 비밀번호 변경)

- 비밀번호 기반 취약점과 동일한 취약점을 가지고 있다. 


# 7. OAuth 인증의 취약점 

- OAuth 2.0 프레임워크를 사용하여 구축되었을 가능성이 높다.

## 7.1 OAuth 2.0 이란? 

- **OAuth 2.0(Open Authorization 2.0)** 은 인증을 위한 **개방형 표준 프로토콜**이다.
- **authorization protocol** 이다. authentication protocol이 아니다.
- 주로 원격 API 또는 사용자 데이터와 같은 리소스 집합에 대한 **액세스 권한**을 부여하는 수단으로 설계되었다.
- **액세스 토큰**을 사용한다. 액세스 토큰은 최종 사용자를 대신하여 리소스에 액세스할 수 있는 권한을 나타내는 데이터 조각이다. 
- 액세스 토큰에 대한 특정 형식을 정의하지 않지만, JWT 형식이 사용되는 경우가 많다. 

**OAuth Role(역할)** 
- **Resource Owner**(리소스 소유자) :  사용자, 보호된 리소스의 주인 
- **Client**(클라이언트): 사용자가 사용하는 애플리케이션, 보호된 리소스에 액세스가 필요한 시스템
- **Authorization Server**(인증 서버) : 인증 처리 및 토큰 발행 해주는 서버, 성공적인 인증 및 리소스 소유자의 동의 시 액세스 토큰을 발행한다. 인증 서버는 두개의 엔드포인트가 있다.  
   Authorization endpoint - 사용자의 대화형 인증 및 동의를 처리
   Token endpoint - 기계간 상호작용 및 토큰 발행
- **Resource Server**(리소스 서버) : 사용자의 리소스를 갖고 있는 서버 , 클라이언트로부터 액세스 토큰을 승인 및 검증하고 적절한 리소스를 반환한다.  

- 인증 서버와 리소스 서버는 동일 한 서버일 수 도 있다. 
- **OAuth service provider**(OAuth 서비스 제공업체): 인증서버와 리소스서버와 상호작용하기 위한 API를 제공하여 OAuth를 지원한다. 

## 7.2 Grant Types in OAuth 2.0 (부여 유형)

**OAuth Scope(범위)**

> 리소스에 대한 액세스 권한의 범위를 정하는 것 

- 허용되는 범위와 리소스는 리소스서버에 따라 다르다. 


**Grants(권한 부여) 란?**

> 권한 부여는 클라이언트가 리소스 액세스 권한을 얻기 위해 수행해야 하는 일련의 단계

- 권한 부여 유형에는 여러가지 가지가 있지만 대표적인 두개만 확인 

### Authorization Code Grant(인증코드 부여유형)
![[Pasted image 20231216115427.png]]

**1. 승인 요청**

클라이언트 애플리케이션이 OAuth 서비스의 **`/authorization` 엔드포인트**에 특정 사용자 데이터에 액세스할 수 있는 권한을 요청 한다.

```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24
HTTP/1.1 Host: oauth-authorization-server.com
```

- `client_id`
	**클라이언트 애플리케이션의 고유 식별자**를 포함하는 필수 매개변수이다. 이 값은 클라이언트 애플리케이션이 OAuth 서비스에 등록될 때 생성된다.

- `redirect_uri`
	클라이언트 애플리케이션에 인증 코드를 보낼 때 사용자 브라우저가 리디렉션되어야 하는 URI이다. 이는 **"콜백 URI"**, 또는 "콜백 끝점" 이라고도 알려져 있다. 많은 OAuth 공격은 이 매개변수 검증의 결함을 악용하는 데 기반을 두고 있다.

- `response_type`
	클라이언트 애플리케이션이 기대하는 응답 종류와 그에 따라 시작하려는 흐름을 결정한다.  **인증 코드 부여 유형의 경우 값은 `code`** 이어야 한다.

- `scope`
	**승인을 요청하는 범위**를 지정하는 데 사용된다. 이는 OAuth 제공자가 설정한 사용자 정의 범위이거나 OpenID Connect(OIDC) 사양에서 정의한(프로필, 이메일 등) 표준화된 범위일 수 있다. 

- `state`
	**CSRF 토큰** 형식으로 사용된다. `/callback` endpoint 요청이 OAuth flow를 시작한 사람과 동일한 사람인지 검증하는 용도이다. 


**2. 이용자 로그인 및 동의**

- **로그인 페이지**로 리디렉션, 종종 소셜미디어 계정이 사용된다. 
- 클라이언트 애플리케이션이 액세스 하려는 데이터 목록이 표시된다. 사용자는 이 접근에 대한 **동의 여부를 선택** 할 수 있다. 
- 처음에는 수동으로 로그인 및 동의 해야 하지만 이후에는 클릭 만으로 되는 경우가 종종있다.


**3. 인증 코드 부여**

- 사용자가 액세스에 동의 후 **`/callback` endpoint** 로 리디렉션 된다. 인증 코드가 쿼리 매개 변수에 포함된다. 

```
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1 Host: client-app.com
```


**4. 액세스 토큰 요청**

- **인증코드를 액세스 토큰으로 교환**해야 한다. 
- 서버간 POST 요청을  OAuth 서비스의 **`/token`엔드포인트**로 보낸다. 
- 이 시점 부터 모든 통신은 안전한 백채널 에서 이루어진다. 그래서 공격자가 관찰 하거나 제어할 수 없다.

```
POST /token HTTP/1.1 
Host: oauth-authorization-server.com 
… 
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```

- `client_secret`
	OAuth 서비스에 등록할 때 할당된 비밀 키이다. 클라이언트 애플리케이션 자신을 인증하는 용도 이다.  

- `grant_type`
	새 엔드포인트가 클라이언트 애플리케이션이 사용하려는 부여 유형을 알고 있는지 확인하는 데 사용된다. 이 경우 `authorization_code`이다.


**5. 액세스 토큰 부여**

- OAuth 서비스는 액세스 토큰 요청의 유효성을 검사 후 클라이언트 애플리케이션에 요청된 범위의 **액세스 토큰을 부여**한다. 
```
{
    "access_token": "z0y9x8w7v6u5",
    "token_type": "Bearer",
    "expires_in": 3600,
    "scope": "openid profile",
    …
}
```


**6. API 호출**

- 클라이언트 애플리케이션에 액세스 코드가 있으므로 드디어 리소스 서버에서 사용자 데이터를 가져올 수 있다.
- OAuth 서비스의 **`/userinfo` 엔드포인트에 대한 API 호출**을 수행
- **액세스 토큰은 `Authorization: Bearer` 헤더**에 제출된다.

```
GET /userinfo HTTP/1.1
Host: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```


**7. 자원 부여**

- 리소스 서버는 토큰이 유효하고 현재 클라이언트 애플리케이션에 속해 있는지 확인한다.
- 액세스 토큰의 범위에 따라 **사용자의 데이터를 전송**

```
{
    "username":"carlos",
    "email":"carlos@carlos-montoya.net",
    …
}
```



> reference
> https://auth0.com/intro-to-iam/what-is-oauth-2
> https://datatracker.ietf.org/doc/html/rfc6749#section-1